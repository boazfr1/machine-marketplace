// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createCreditCard = `-- name: CreateCreditCard :one
INSERT INTO credit_cards (owner_id, number, expiration_date, secret)
VALUES ($1, $2, $3, $4)
RETURNING id, owner_id, number, expiration_date, secret
`

type CreateCreditCardParams struct {
	OwnerID        int32
	Number         int32
	ExpirationDate string
	Secret         int32
}

func (q *Queries) CreateCreditCard(ctx context.Context, arg CreateCreditCardParams) (CreditCard, error) {
	row := q.db.QueryRowContext(ctx, createCreditCard,
		arg.OwnerID,
		arg.Number,
		arg.ExpirationDate,
		arg.Secret,
	)
	var i CreditCard
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Number,
		&i.ExpirationDate,
		&i.Secret,
	)
	return i, err
}

const createMachine = `-- name: CreateMachine :one
INSERT INTO machines (
    name,
    ram,
    cpu,
    memory,
    key,
    owner_id,
    buyer_id,
    host,
    ssh_user
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    NULL,
    $7,
    $8
) RETURNING id, name, buyer_id, owner_id, ram, cpu, memory, key, host, ssh_user
`

type CreateMachineParams struct {
	Name    string
	Ram     int32
	Cpu     int32
	Memory  int32
	Key     sql.NullString
	OwnerID int32
	Host    string
	SshUser string
}

func (q *Queries) CreateMachine(ctx context.Context, arg CreateMachineParams) (Machine, error) {
	row := q.db.QueryRowContext(ctx, createMachine,
		arg.Name,
		arg.Ram,
		arg.Cpu,
		arg.Memory,
		arg.Key,
		arg.OwnerID,
		arg.Host,
		arg.SshUser,
	)
	var i Machine
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BuyerID,
		&i.OwnerID,
		&i.Ram,
		&i.Cpu,
		&i.Memory,
		&i.Key,
		&i.Host,
		&i.SshUser,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, email, password)
VALUES ($1, $2, $3::bytea)
RETURNING id, name, email, password
`

type CreateUserParams struct {
	Name    string
	Email   string
	Column3 []byte
}

// query.sql
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.Column3)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const getCreditCardsByOwnerID = `-- name: GetCreditCardsByOwnerID :many
SELECT id, owner_id, number, expiration_date, secret FROM credit_cards WHERE owner_id = $1
`

func (q *Queries) GetCreditCardsByOwnerID(ctx context.Context, ownerID int32) ([]CreditCard, error) {
	rows, err := q.db.QueryContext(ctx, getCreditCardsByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreditCard
	for rows.Next() {
		var i CreditCard
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Number,
			&i.ExpirationDate,
			&i.Secret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMachineByID = `-- name: GetMachineByID :one
SELECT id, name, buyer_id, owner_id, ram, cpu, memory, key, host, ssh_user FROM machines WHERE id = $1
`

func (q *Queries) GetMachineByID(ctx context.Context, id int32) (Machine, error) {
	row := q.db.QueryRowContext(ctx, getMachineByID, id)
	var i Machine
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BuyerID,
		&i.OwnerID,
		&i.Ram,
		&i.Cpu,
		&i.Memory,
		&i.Key,
		&i.Host,
		&i.SshUser,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const getUserCreditCards = `-- name: GetUserCreditCards :many
SELECT id, owner_id, number, expiration_date, secret FROM credit_cards WHERE owner_id = $1
`

func (q *Queries) GetUserCreditCards(ctx context.Context, ownerID int32) ([]CreditCard, error) {
	rows, err := q.db.QueryContext(ctx, getUserCreditCards, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreditCard
	for rows.Next() {
		var i CreditCard
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Number,
			&i.ExpirationDate,
			&i.Secret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailableMachines = `-- name: ListAvailableMachines :many
SELECT id, name, buyer_id, owner_id, ram, cpu, memory, key, host, ssh_user FROM machines WHERE buyer_id IS NULL
`

func (q *Queries) ListAvailableMachines(ctx context.Context) ([]Machine, error) {
	rows, err := q.db.QueryContext(ctx, listAvailableMachines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Machine
	for rows.Next() {
		var i Machine
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BuyerID,
			&i.OwnerID,
			&i.Ram,
			&i.Cpu,
			&i.Memory,
			&i.Key,
			&i.Host,
			&i.SshUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMachinesByBuyerID = `-- name: ListMachinesByBuyerID :many
SELECT ram, cpu, memory, name FROM machines WHERE buyer_id = $1
`

type ListMachinesByBuyerIDRow struct {
	Ram    int32
	Cpu    int32
	Memory int32
	Name   string
}

func (q *Queries) ListMachinesByBuyerID(ctx context.Context, buyerID sql.NullInt32) ([]ListMachinesByBuyerIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listMachinesByBuyerID, buyerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMachinesByBuyerIDRow
	for rows.Next() {
		var i ListMachinesByBuyerIDRow
		if err := rows.Scan(
			&i.Ram,
			&i.Cpu,
			&i.Memory,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMachinesByOwnerID = `-- name: ListMachinesByOwnerID :many
SELECT id, name, buyer_id, owner_id, ram, cpu, memory, key, host, ssh_user FROM machines WHERE owner_id = $1
`

func (q *Queries) ListMachinesByOwnerID(ctx context.Context, ownerID int32) ([]Machine, error) {
	rows, err := q.db.QueryContext(ctx, listMachinesByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Machine
	for rows.Next() {
		var i Machine
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BuyerID,
			&i.OwnerID,
			&i.Ram,
			&i.Cpu,
			&i.Memory,
			&i.Key,
			&i.Host,
			&i.SshUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMachineBuyer = `-- name: UpdateMachineBuyer :one
UPDATE machines 
SET buyer_id = $1, key = $2
WHERE id = $3 AND buyer_id IS NULL
RETURNING id, name, buyer_id, owner_id, ram, cpu, memory, key, host, ssh_user
`

type UpdateMachineBuyerParams struct {
	BuyerID sql.NullInt32
	Key     sql.NullString
	ID      int32
}

func (q *Queries) UpdateMachineBuyer(ctx context.Context, arg UpdateMachineBuyerParams) (Machine, error) {
	row := q.db.QueryRowContext(ctx, updateMachineBuyer, arg.BuyerID, arg.Key, arg.ID)
	var i Machine
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BuyerID,
		&i.OwnerID,
		&i.Ram,
		&i.Cpu,
		&i.Memory,
		&i.Key,
		&i.Host,
		&i.SshUser,
	)
	return i, err
}
